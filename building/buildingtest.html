
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel = "stylesheet" type = "text/css" href = "buildingstyle.css" />
    <script type="text/javascript" src="https://d3js.org/d3.v3.min.js"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
  </head>

<body>

<div id="chart"></div>
<script>

var width = 2000,
    height = 1000,
    window_width = 15,
    window_height = 15,
    building_width = 90,
    legend_block_width = 60,
    legend_block_height = 20,
    buckets = 3,
    coColors = ["#60C60E", "#F0C88D", "#F6D426"], //window colours
    coLabels = ["High", "Medium", "Low", "Not mentioned"],
    maxClassSizeSet = [],
    windows = [],
    varNames = [],
    wordNum = 0,
    studentPos = [];

//read data from json
var data = d3.json("buildingdata.json", function(error, data) {
    console.log(error);
    data.forEach(function(d) {
        d.word = d.word;
        d.wordNum = +d.wordNum;
        d.hiCo = +d.hiCo;
        d.medCo = +d.medCo;
        d.lowCo = +d.lowCo;
        d.notMentioned = d.classSize - (d.hiCo + d.medCo + d.lowCo);
        d.classSize = d.classSize-d.notMentioned;
        d.studentCo = d.studentCo;


        maxClassSizeSet.push(d.classSize); //collect class size for each word

        //generate array variable names for each word
        varNames[d.wordNum] = "word" + d.wordNum + "Windows";
        window[varNames[d.wordNum]] = [];

        //build window data
        var xPos = 0,
            yPos = 0,
            coherence;
        //add x/y position and colour to window object array

        if (d.studentCo=="high") { //check for student coherence, get position of first coherence window if it matches
            studentPos[d.wordNum] = { x: xPos, y: yPos};
        }    
        for (var i=0; i<d.hiCo; i++) {
            eval(varNames[d.wordNum] + ".push({ x: xPos, y: yPos, coherence: coColors[0] });");
            if(xPos<40) {
                xPos+=20;
            }
            else { //start new row of windows
                xPos=0;
                yPos+=25;
            }
        }

        if (d.studentCo=="med") { 
            studentPos[d.wordNum] = { x: xPos, y: yPos};
        }   
        for (var i=0; i<d.medCo; i++) {
            eval(varNames[d.wordNum] + ".push({ x: xPos, y: yPos, coherence: coColors[1] });");
            if(xPos<40) {
                xPos+=20;
            }
            else {
                xPos=0;
                yPos+=25;
            }
        }

        if (d.studentCo=="low") { 
            studentPos[d.wordNum] = { x: xPos, y: yPos};
        }   
        for (var i=0; i<d.lowCo; i++) {
            eval(varNames[d.wordNum] + ".push({ x: xPos, y: yPos, coherence: coColors[2] });");
            if(xPos<40) {
                xPos+=20;
            }
            else {
                xPos=0;
                yPos+=25;
            }
        }

        if (d.studentCo=="notMentioned") {
            studentPos[d.wordNum] = { x: xPos, y: yPos};
        }

        // for (var i=0; i<d.notMentioned; i++) {
        //     eval(varNames[d.wordNum] + ".push({ x: xPos, y: yPos, coherence: coColors[3] });");
        //     if(xPos<40) {
        //         xPos+=20;
        //     }
        //     else {
        //         xPos=0;
        //         yPos+=20;
        //     }
        // }
    }
    );

//TODO: clean up SVG structure

var maxClassSize = d3.max(maxClassSizeSet); //find max class size to line up buildings/windows at the bottom

    var svg = d3.select("#chart").append("svg")
        .attr("width", width)
        .attr("height", height);

    var colorScale = d3.scale.quantile()
              .domain([0, buckets - 1, d3.max(data, function (d) { return d.value; })])
              .range(coColors);

    var legend = svg.selectAll(".legend")
    .data([0].concat(colorScale.quantiles()), function(d) { return d;})
    .enter().append("g")
    .attr("class", "legend");

  legend.append("rect")
    .attr("x", function(d,i) { return 20 + legend_block_width*i;})
    .attr("y", 30)
    .attr("width", legend_block_width)
    .attr("height", legend_block_height)
    .style("fill", function(d, i) { return coColors[i]; });

  legend.append("text")
    .attr("class", "legend_label")
    .attr("x", function(d,i) {return 20 + legend_block_width*i + legend_block_width/2;})
    .attr("y", 60)
    .attr("text-anchor", "middle")
    .text(function(d, i) { return coLabels[i]; });

    legend.append("text")
        .attr("class", "heading")
        .attr("x", 20)
        .attr("y", 20)
        .text("Legend: Coherence levels");


    // var student = svg.selectAll(".student") //individual coherence
    //     .data(data)
    //     .enter().append("g")
    //     .attr("class", "student")
    //     .attr("transform", function(d) {return "translate(" + d.wordNum*building_width + "," + ((window_height*Math.ceil(maxClassSize/3) + Math.ceil(maxClassSize/3)*5 + 15*2) - (window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*5 + 15*2)) + ")"; })
    //     .append("rect")
    //         .attr("x", building_width/4)
    //         .attr("y", 0)
    //         .attr("width", building_width/2)
    //         .attr("height", 40)
    //         .attr("fill", function(d) {
    //             if(d.studentCo=="high") return coColors[0];
    //             else if(d.studentCo=="med") return coColors[1];
    //             else if(d.studentCo=="low") return coColors[2];
    //             else if(d.studentCo=="notMentioned") return coColors[3];
    //         });

    // var studentLabels = svg.selectAll(".studentLabels")
    //     .data(data)
    //     .enter().append("g")
    //     .attr("transform", function(d) {return "translate(" + d.wordNum*building_width + "," + ((window_height*Math.ceil(maxClassSize/3) + Math.ceil(maxClassSize/3)*5 + 15*2) - (window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*5 + 15*2)) + ")";})
    //     .append("text")
    //         .attr("x", building_width/2)
    //         .attr("y", 20)
    //         .text(function(d) {if(d.studentCo=="high") return coLabels[0];
    //                             else if(d.studentCo=="med") return coLabels[1];
    //                             else if(d.studentCo=="low") return coLabels[2];
    //                             else if(d.studentCo=="notMentioned") return coLabels[3];
    //         })
    //         .attr("text-anchor", "middle");

    //tip showing coherence percentages of the selected word
    var tip = d3.tip()
        .attr("class", "d3-tip")
        .offset([300, 0]) //TODO: fix offset
        .html(function(d) {return "High coherence: " + percentage(d.classSize, d.hiCo) + "<br/>" + 
            "Medium coherence: " + percentage(d.classSize, d.medCo) + "<br/>" +
            "Low coherence: " + percentage(d.classSize, d.lowCo) + "<br/>" + 
            "Not mentioned: " + percentage(d.classSize, d.notMentioned);});

    svg.call(tip);

    var buildings = svg.selectAll(".building")
        .data(data)
        .enter().append("g")
        .attr("class", "building")
        .attr("transform", function(d) { return "translate(" + (d.wordNum*building_width+2) + "," + ((window_height*Math.ceil(maxClassSize/3) + Math.ceil(maxClassSize/3)*10 + 15*2) - (window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*10 + 15*2) + 40) + ")"; })
        .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", building_width)
            .attr("height", function(d) { return window_height* Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*10 + 20*2;})
        .on("mouseover", tip.show)
        .on("mouseout", tip.hide);


    var buildingLabels = svg.selectAll(".buildingLabels") //word number 
        .data(data)
        .enter().append("g")
        .attr("transform", function(d) { return "translate(" + d.wordNum*building_width + "," + (window_height*maxClassSize/3 + maxClassSize/3*10 + 15*2) + ")";})
        .append("text")
            .attr("x", building_width/2)
            .attr("y", 80)
            .text(function(d) {return d.word;})
            .attr("text-anchor", "middle");

    var windows = svg.selectAll(".windows")
        .data(data)
        .enter().append("g")
        .attr("class", "windows")
        .attr("transform", function(d) { return "translate(" + (d.wordNum*building_width+20) + "," + ((window_height*Math.ceil(maxClassSize/3) + Math.ceil(maxClassSize/3)*10 + 15*2) - (window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*10 + 15*2) + 60) + ")"; });

    var lineFunction = d3.svg.line()
        .x(function(d) {return d.x;})
        .y(function(d) {return d.y;})
        .interpolate("linear");

    var coherenceWindows = windows.selectAll(".coherence")
        .data(function (d) { 
            var name = "word" + wordNum + "Windows";
            var name = window[name];
            wordNum++;
            return name;})
        .enter().append("g")
        .attr("class", "windowPane")

    coherenceWindows.append("rect") //base window
        .attr("x", function(d) { return d.x;})
        .attr("y", function(d) {return d.y;})
        .attr("width", window_width)
        .attr("height", window_height)
        .style("fill", function(d) {return d.coherence;})
        .style("stroke", "white");

    coherenceWindows.append("rect") //window edges
        .attr("class", "window_effect")
        .attr("x", function(d) { return d.x + window_width/2;})
        .attr("y", function(d) {return d.y;})
        .attr("width", 2)
        .attr("height", window_height);

    coherenceWindows.append("rect")
        .attr("class", "window_effect_dark")
        .attr("x", function(d) { return d.x-1;})
        .attr("y", function(d) {return d.y+window_height;})
        .attr("width", window_width+2)
        .attr("height", 3);


    var student = svg.selectAll(".student") //user coherence shown as dot in each building
        .data(data)
        .enter().append("g")
        .attr("transform", function(d) {return "translate(" + (d.wordNum*building_width+20) + "," + ((window_height*Math.ceil(maxClassSize/3) + Math.ceil(maxClassSize/3)*10 + 15*2) - (window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*10 + 15*2) + 60) + ")";});

    student.append("circle")//face
        .attr("cx", function(d,i) {return studentPos[i].x + 7;})
        .attr("cy", function(d,i) {return studentPos[i].y + 7;})
        .attr("r", 6)
        .attr("stroke", "white");
        
    student.append("circle") //eyes
        .attr("cx", function(d,i) {return studentPos[i].x + 4;})
        .attr("cy", function(d,i) {return studentPos[i].y + 7;})
        .attr("r", 1)
        .style("fill", "white");
    student.append("circle") //eyes
        .attr("cx", function(d,i) {return studentPos[i].x + 8;})
        .attr("cy", function(d,i) {return studentPos[i].y + 7;})
        .attr("r", 1)
        .style("fill", "white");
    student.append("ellipse") //mouth
        .attr("cx", function(d,i) {return studentPos[i].x + 6;})
        .attr("cy", function(d,i) {return studentPos[i].y + 10;})
        .attr("rx", 3)
        .attr("ry", 1)
        .style("fill", "white");

    // var windowOverlay = windows.selectAll(".windowPane")
    //     .data(function (d) {
    //         var name = "word" + wordNum + "Windows";
    //         var name = window[name];
    //         wordNum++;
    //         return name;})
    //     .enter()
    //     .append("path") //translucent "glass" overlay
    //     .attr("d", lineFunction([{"x": d.x, "y": d.y + window_height/3},
    //                              {"x": d.x, "y": d.y + window_height},
    //                              {"x": d.x + window_width, "y": d.y + window_height},
    //                              {"x": d.x + window_width/3, "y": d.y + window_height/1.5}]));
    
    });
    //find percentage of coherence
    function percentage(classSize, coherence) {
        return (coherence/classSize*100).toFixed(0) + "%";
    }


</script>
</body>
</html>

<!-- This visualization aims to show your performance in relation to the entire class. Each building represents a different word in the assignment. The coloured windows represent the performance of other students in the class - the darker the colour, the better their performance. Your own performance is indicated by the block on top of the building. -->


<!-- TODO**
building height reflects how many students responded (remove white (not mentioned) windows)

find better way for user to compare with the rest of the class

give user mini questionnaires (text/radio) under visualizations depending on how many times they look at viz

d3 chord graph -->