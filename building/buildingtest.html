
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel = "stylesheet" type = "text/css" href = "buildingstyle.css" />
    <script type="text/javascript" src="https://d3js.org/d3.v3.min.js"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
  </head>

<body>

<div id="chart"></div>
<script>

var width = 2000,
    height = 1000,
    window_width = 15,
    window_height = 15,
    building_width = 90,
    legend_block_width = 60,
    legend_block_height = 20,
    buckets = 3,
    coColors = ["#60C60E", "#F0C88D", "#F6D426", "2d2d2d"], //window colours
    coLabels = ["High", "Medium", "Low", "Not mentioned"],
    maxClassSizeSet = [],
    windows = [],
    varNames = [],
    wordNum = 0,
    studentPos = [];

//read data from json
var data = d3.json("buildingdata.json", function(error, data) {
    console.log(error);
    data.forEach(function(d) {
        d.word = d.word;
        d.wordNum = +d.wordNum;
        d.hiCo = +d.hiCo;
        d.medCo = +d.medCo;
        d.lowCo = +d.lowCo;
        d.notMentioned = d.classSize - (d.hiCo + d.medCo + d.lowCo);
        d.classSize = d.classSize-d.notMentioned;
        d.studentCo = d.studentCo;


        maxClassSizeSet.push(d.classSize); //collect class size for each word

        //generate array variable names for each word
        varNames[d.wordNum] = "word" + d.wordNum + "Windows";
        window[varNames[d.wordNum]] = [];

        //build window data
        var xPos = 0,
            yPos = 0,
            coherence;
        //add x/y position and colour to window object array

        if (d.studentCo=="high") { //check for student coherence, get position of first coherence window if it matches
            studentPos[d.wordNum] = { x: xPos, y: yPos};
        }    
        for (var i=0; i<d.hiCo; i++) {
            eval(varNames[d.wordNum] + ".push({ x: xPos, y: yPos, coherence: coColors[0] });");
            if(xPos<40) {
                xPos+=20;
            }
            else { //start new row of windows
                xPos=0;
                yPos+=25;
            }
        }

        if (d.studentCo=="med") { 
            studentPos[d.wordNum] = { x: xPos, y: yPos};
        }   
        for (var i=0; i<d.medCo; i++) {
            eval(varNames[d.wordNum] + ".push({ x: xPos, y: yPos, coherence: coColors[1] });");
            if(xPos<40) {
                xPos+=20;
            }
            else {
                xPos=0;
                yPos+=25;
            }
        }

        if (d.studentCo=="low") { 
            studentPos[d.wordNum] = { x: xPos, y: yPos};
        }   
        for (var i=0; i<d.lowCo; i++) {
            eval(varNames[d.wordNum] + ".push({ x: xPos, y: yPos, coherence: coColors[2] });");
            if(xPos<40) {
                xPos+=20;
            }
            else {
                xPos=0;
                yPos+=25;
            }
        }

        if (d.studentCo=="notMentioned") {
            studentPos[d.wordNum] = { x: xPos, y: yPos};
        }

        // for (var i=0; i<d.notMentioned; i++) {
        //     eval(varNames[d.wordNum] + ".push({ x: xPos, y: yPos, coherence: coColors[3] });");
        //     if(xPos<40) {
        //         xPos+=20;
        //     }
        //     else {
        //         xPos=0;
        //         yPos+=20;
        //     }
        // }
    }
    );


var maxClassSize = d3.max(maxClassSizeSet); //find max class size to line up buildings/windows at the bottom

//TODO: add "baseline"

    var svg = d3.select("#chart").append("svg")
        .attr("width", width)
        .attr("height", height);

    //LEGEND
    var colorScale = d3.scale.quantile()
              .domain([0, buckets - 1, d3.max(data, function (d) { return d.value; })])
              .range(coColors);

    var legend = svg.selectAll(".legend")
    .data([0].concat(colorScale.quantiles()), function(d) { return d;})
    .enter().append("g")
    .attr("class", "legend");

    legend.append("rect")
    .attr("x", function(d,i) { return 20 + legend_block_width*i;})
    .attr("y", 30)
    .attr("width", legend_block_width)
    .attr("height", legend_block_height)
    .style("fill", function(d, i) { return coColors[i]; })
    .style("stroke", "white");

    legend.append("text")
    .attr("class", "legend_label")
    .attr("x", function(d,i) {return 20 + legend_block_width*i + legend_block_width/2;})
    .attr("y", 60)
    .attr("text-anchor", "middle")
    .text(function(d, i) { return coLabels[i]; });

    legend.append("text")
        .attr("class", "heading")
        .attr("x", 20)
        .attr("y", 20)
        .text("Legend: Coherence levels");


    // var student = svg.selectAll(".student") //individual coherence
    //     .data(data)
    //     .enter().append("g")
    //     .attr("class", "student")
    //     .attr("transform", function(d) {return "translate(" + d.wordNum*building_width + "," + ((window_height*Math.ceil(maxClassSize/3) + Math.ceil(maxClassSize/3)*5 + 15*2) - (window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*5 + 15*2)) + ")"; })
    //     .append("rect")
    //         .attr("x", building_width/4)
    //         .attr("y", 0)
    //         .attr("width", building_width/2)
    //         .attr("height", 40)
    //         .attr("fill", function(d) {
    //             if(d.studentCo=="high") return coColors[0];
    //             else if(d.studentCo=="med") return coColors[1];
    //             else if(d.studentCo=="low") return coColors[2];
    //             else if(d.studentCo=="notMentioned") return coColors[3];
    //         });

    // var studentLabels = svg.selectAll(".studentLabels")
    //     .data(data)
    //     .enter().append("g")
    //     .attr("transform", function(d) {return "translate(" + d.wordNum*building_width + "," + ((window_height*Math.ceil(maxClassSize/3) + Math.ceil(maxClassSize/3)*5 + 15*2) - (window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*5 + 15*2)) + ")";})
    //     .append("text")
    //         .attr("x", building_width/2)
    //         .attr("y", 20)
    //         .text(function(d) {if(d.studentCo=="high") return coLabels[0];
    //                             else if(d.studentCo=="med") return coLabels[1];
    //                             else if(d.studentCo=="low") return coLabels[2];
    //                             else if(d.studentCo=="notMentioned") return coLabels[3];
    //         })
    //         .attr("text-anchor", "middle");

    //tip showing coherence percentages of the selected word
    //find percentage of coherence
    function percentage(classSize, coherence) {
        return (coherence/classSize*100).toFixed(0) + "%";
    }

    var tip = d3.tip()
        .attr("class", "d3-tip")
        .html(function(d) {return "High coherence: " + percentage(d.classSize, d.hiCo) + "<br/>" + 
            "Medium coherence: " + percentage(d.classSize, d.medCo) + "<br/>" +
            "Low coherence: " + percentage(d.classSize, d.lowCo) + "<br/>" + 
            "Not mentioned: " + percentage(d.classSize, d.notMentioned);});

    svg.call(tip);

    //BUILDINGS
    var buildings = svg.selectAll(".building")
        .data(data)
        .enter().append("g")
        .attr("class", "building")
        .attr("transform", function(d) { return "translate(" + (20 + d.wordNum*building_width+2) + "," + (40 + (window_height*Math.ceil(maxClassSize/3) + Math.ceil(maxClassSize/3)*10 + 15*2) - (window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*10 + 15*2) + 40) + ")"; })

    buildings.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", building_width)
        .attr("height", function(d) { return window_height* Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*10 + 20*2 + 20;})
        .style("fill", "#184D81")
        .style("stroke", "white")
        .on("mouseover", tip.show)
        .on("mouseout", tip.hide);

    //keyword labels
    buildings.append("text")
            .attr("x", building_width/2)
            .attr("y", function(d) { return 30 + window_height*Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*10 + 15*2 + 20;})
            .attr("text-anchor", "middle")
            .text(function(d) {return d.word;});

    //coherence windows
    var windows = buildings.append("g")
        .attr("class", "windows")
        .attr("transform", "translate(" + 20 + "," + 20 + ")")
        .on("mouseover", tip.show)
        .on("mouseout", tip.hide);

    var coherenceWindows = windows.selectAll(".coherence")
        .data(function (d) { 
            var name = "word" + wordNum + "Windows";
            var name = window[name];
            wordNum++;
            return name;})
        .enter().append("g")
        .attr("class", "windowPane");

    coherenceWindows.append("rect") //base window
        .attr("x", function(d) { return d.x;})
        .attr("y", function(d) {return d.y;})
        .attr("width", window_width)
        .attr("height", window_height)
        .style("fill", function(d) {return d.coherence;})
        .style("stroke", "white");

    // coherenceWindows.append("rect") //window edges
    //     .attr("class", "window_effect")
    //     .attr("x", function(d) { return d.x + window_width/2;})
    //     .attr("y", function(d) {return d.y;})
    //     .attr("width", 2)
    //     .attr("height", window_height);

    coherenceWindows.append("rect") //windowsill
        .attr("class", "window_effect_dark")
        .attr("x", function(d) { return d.x;})
        .attr("y", function(d) {return d.y+window_height;})
        .attr("width", window_width+2)
        .attr("height", 3);

    //STUDENT
    // var student = buildings.append("g")
    //     .attr("class", "student")
    //     .attr("transform", "translate(" + 20 + "," + 20 + ")");

    // student.append("circle")//face
    //     .attr("cx", function(d,i) {return studentPos[i].x + 7;})
    //     .attr("cy", function(d,i) {return studentPos[i].y + 7;})
    //     .attr("r", 6)
    //     .attr("stroke", "white");
        
    // student.append("circle") //eyes
    //     .attr("cx", function(d,i) {return studentPos[i].x + 4;})
    //     .attr("cy", function(d,i) {return studentPos[i].y + 7;})
    //     .attr("r", 1)
    //     .style("fill", "white");
    // student.append("circle") //eyes
    //     .attr("cx", function(d,i) {return studentPos[i].x + 8;})
    //     .attr("cy", function(d,i) {return studentPos[i].y + 7;})
    //     .attr("r", 1)
    //     .style("fill", "white");
    // student.append("ellipse") //mouth
    //     .attr("cx", function(d,i) {return studentPos[i].x + 6;})
    //     .attr("cy", function(d,i) {return studentPos[i].y + 10;})
    //     .attr("rx", 3)
    //     .attr("ry", 1)
    //     .style("fill", "white");

    //top coherence block
    var studentBlock = buildings.append("rect")
        .attr("class", "studentBlock")
        .attr("transform", "translate(" + 15 + "," + -10 + ")")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", building_width*0.7)
        .attr("height", 10)
        .style("fill", function(d) { 
            if(d.studentCo=="high") return coColors[0];
            else if(d.studentCo=="med") return coColors[1];
            else if(d.studentCo=="low") return coColors[2];
            else return "black"; });

    var bottomBlock = buildings.append("rect")
        .attr("class", "bottomBlock")
        .attr("transform", function(d) { return "translate(" + 15 + "," + (window_height* Math.ceil(d.classSize/3) + Math.ceil(d.classSize/3)*10 + 25) + ")";})
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", building_width*0.7)
        .attr("height", 15)
        .style("fill", function(d) { 
            if(d.studentCo=="high") return coColors[0];
            else if(d.studentCo=="med") return coColors[1];
            else if(d.studentCo=="low") return coColors[2];
            else return "black"; });



    
    });

</script>
</body>
</html>

<!-- This visualization aims to show your performance in relation to the entire class. Each building represents a different word in the assignment. The coloured windows represent the performance of other students in the class - the darker the colour, the better their performance. Your own performance is indicated by the block on top of the building. -->


<!-- TODO**
building height reflects how many students responded (remove white (not mentioned) windows)

find better way for user to compare with the rest of the class

give user mini questionnaires (text/radio) under visualizations depending on how many times they look at viz

d3 chord graph -->